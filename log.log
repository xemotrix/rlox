SCRIPT  /usr/local/Cellar/neovim/0.8.1/share/nvim/runtime/syntax/rust.vim
Sourced 2 times
Total time:   0.001266
 Self time:   0.001266

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Rust
                            " Maintainer:   Patrick Walton <pcwalton@mozilla.com>
                            " Maintainer:   Ben Blum <bblum@cs.cmu.edu>
                            " Maintainer:   Chris Morgan <me@chrismorgan.info>
                            " Last Change:  Feb 24, 2016
                            " For bugs, patches and license go to https://github.com/rust-lang/rust.vim
                            
    2              0.000006 if version < 600
                            	syntax clear
    2              0.000007 elseif exists("b:current_syntax")
                            	finish
    2              0.000001 endif
                            
                            " Syntax definitions {{{1
                            " Basic keywords {{{2
    2              0.000007 syn keyword   rustConditional match if else
    2              0.000005 syn keyword   rustRepeat for loop while
    2              0.000008 syn keyword   rustTypedef type nextgroup=rustIdentifier skipwhite skipempty
    2              0.000006 syn keyword   rustStructure struct enum nextgroup=rustIdentifier skipwhite skipempty
    2              0.000006 syn keyword   rustUnion union nextgroup=rustIdentifier skipwhite skipempty contained
    2              0.000023 syn match rustUnionContextual /\<union\_s\+\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*/ transparent contains=rustUnion
    2              0.000003 syn keyword   rustOperator    as
                            
    2              0.000007 syn match     rustAssert      "\<assert\(\w\)*!" contained
    2              0.000006 syn match     rustPanic       "\<panic\(\w\)*!" contained
    2              0.000003 syn keyword   rustKeyword     break
    2              0.000006 syn keyword   rustKeyword     box nextgroup=rustBoxPlacement skipwhite skipempty
    2              0.000003 syn keyword   rustKeyword     continue
    2              0.000010 syn keyword   rustKeyword     extern nextgroup=rustExternCrate,rustObsoleteExternMod skipwhite skipempty
    2              0.000006 syn keyword   rustKeyword     fn nextgroup=rustFuncName skipwhite skipempty
    2              0.000003 syn keyword   rustKeyword     in impl let
    2              0.000004 syn keyword   rustKeyword     pub nextgroup=rustPubScope skipwhite skipempty
    2              0.000002 syn keyword   rustKeyword     return
    2              0.000003 syn keyword   rustSuper       super
    2              0.000004 syn keyword   rustKeyword     unsafe where
    2              0.000004 syn keyword   rustKeyword     use nextgroup=rustModPath skipwhite skipempty
                            " FIXME: Scoped impl's name is also fallen in this category
    2              0.000005 syn keyword   rustKeyword     mod trait nextgroup=rustIdentifier skipwhite skipempty
    2              0.000005 syn keyword   rustStorage     move mut ref static const
    2              0.000011 syn match rustDefault /\<default\ze\_s\+\(impl\|fn\|type\|const\)\>/
                            
    2              0.000003 syn keyword   rustInvalidBareKeyword crate
                            
    2              0.000003 syn keyword rustPubScopeCrate crate contained
    2              0.000006 syn match rustPubScopeDelim /[()]/ contained
    2              0.000014 syn match rustPubScope /([^()]*)/ contained contains=rustPubScopeDelim,rustPubScopeCrate,rustSuper,rustModPath,rustModPathSep,rustSelf transparent
                            
    2              0.000007 syn keyword   rustExternCrate crate contained nextgroup=rustIdentifier,rustExternCrateString skipwhite skipempty
                            " This is to get the `bar` part of `extern crate "foo" as bar;` highlighting.
    2              0.000010 syn match   rustExternCrateString /".*"\_s*as/ contained nextgroup=rustIdentifier skipwhite transparent skipempty contains=rustString,rustOperator
    2              0.000004 syn keyword   rustObsoleteExternMod mod contained nextgroup=rustIdentifier skipwhite skipempty
                            
    2              0.000013 syn match     rustIdentifier  contains=rustIdentifierPrime "\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*" display contained
    2              0.000008 syn match     rustFuncName    "\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*" display contained
                            
    2              0.000013 syn region    rustBoxPlacement matchgroup=rustBoxPlacementParens start="(" end=")" contains=TOP contained
                            " Ideally we'd have syntax rules set up to match arbitrary expressions. Since
                            " we don't, we'll just define temporary contained rules to handle balancing
                            " delimiters.
    2              0.000010 syn region    rustBoxPlacementBalance start="(" end=")" containedin=rustBoxPlacement transparent
    2              0.000008 syn region    rustBoxPlacementBalance start="\[" end="\]" containedin=rustBoxPlacement transparent
                            " {} are handled by rustFoldBraces
                            
    2              0.000013 syn region rustMacroRepeat matchgroup=rustMacroRepeatDelimiters start="$(" end=")" contains=TOP nextgroup=rustMacroRepeatCount
    2              0.000006 syn match rustMacroRepeatCount ".\?[*+]" contained
    2              0.000005 syn match rustMacroVariable "$\w\+"
                            
                            " Reserved (but not yet used) keywords {{{2
    2              0.000017 syn keyword   rustReservedKeyword alignof become do offsetof priv pure sizeof typeof unsized yield abstract virtual final override macro
                            
                            " Built-in types {{{2
    2              0.000010 syn keyword   rustType        isize usize char bool u8 u16 u32 u64 u128 f32
    2              0.000005 syn keyword   rustType        f64 i8 i16 i32 i64 i128 str Self
                            
                            " Things from the libstd v1 prelude (src/libstd/prelude/v1.rs) {{{2
                            " This section is just straight transformation of the contents of the prelude,
                            " to make it easy to update.
                            
                            " Reexported core operators {{{3
    2              0.000005 syn keyword   rustTrait       Copy Send Sized Sync
    2              0.000004 syn keyword   rustTrait       Drop Fn FnMut FnOnce
                            
                            " Reexported functions {{{3
                            " There’s no point in highlighting these; when one writes drop( or drop::< it
                            " gets the same highlighting anyway, and if someone writes `let drop = …;` we
                            " don’t really want *that* drop to be highlighted.
                            "syn keyword rustFunction drop
                            
                            " Reexported types and traits {{{3
    2              0.000003 syn keyword rustTrait Box
    2              0.000002 syn keyword rustTrait ToOwned
    2              0.000003 syn keyword rustTrait Clone
    2              0.000004 syn keyword rustTrait PartialEq PartialOrd Eq Ord
    2              0.000004 syn keyword rustTrait AsRef AsMut Into From
    2              0.000002 syn keyword rustTrait Default
    2              0.000003 syn keyword rustTrait Iterator Extend IntoIterator
    2              0.000003 syn keyword rustTrait DoubleEndedIterator ExactSizeIterator
    2              0.000003 syn keyword rustEnum Option
    2              0.000003 syn keyword rustEnumVariant Some None
    2              0.000003 syn keyword rustEnum Result
    2              0.000003 syn keyword rustEnumVariant Ok Err
    2              0.000003 syn keyword rustTrait SliceConcatExt
    2              0.000003 syn keyword rustTrait String ToString
    2              0.000002 syn keyword rustTrait Vec
                            
                            " Other syntax {{{2
    2              0.000003 syn keyword   rustSelf        self
    2              0.000003 syn keyword   rustBoolean     true false
                            
                            " If foo::bar changes to foo.bar, change this ("::" to "\.").
                            " If foo::bar changes to Foo::bar, change this (first "\w" to "\u").
    2              0.000009 syn match     rustModPath     "\w\(\w\)*::[^<]"he=e-3,me=e-3
    2              0.000005 syn match     rustModPathSep  "::"
                            
    2              0.000006 syn match     rustFuncCall    "\w\(\w\)*("he=e-1,me=e-1
    2              0.000006 syn match     rustFuncCall    "\w\(\w\)*::<"he=e-3,me=e-3 " foo::<T>();
                            
                            " This is merely a convention; note also the use of [A-Z], restricting it to
                            " latin identifiers rather than the full Unicode uppercase. I have not used
                            " [:upper:] as it depends upon 'noignorecase'
                            "syn match     rustCapsIdent    display "[A-Z]\w\(\w\)*"
                            
    2              0.000009 syn match     rustOperator     display "\%(+\|-\|/\|*\|=\|\^\|&\||\|!\|>\|<\|%\)=\?"
                            " This one isn't *quite* right, as we could have binary-& with a reference
    2              0.000009 syn match     rustSigil        display /&\s\+[&~@*][^)= \t\r\n]/he=e-1,me=e-1
    2              0.000007 syn match     rustSigil        display /[&~@*][^)= \t\r\n]/he=e-1,me=e-1
                            " This isn't actually correct; a closure with no arguments can be `|| { }`.
                            " Last, because the & in && isn't a sigil
    2              0.000005 syn match     rustOperator     display "&&\|||"
                            " This is rustArrowCharacter rather than rustArrow for the sake of matchparen,
                            " so it skips the ->; see http://stackoverflow.com/a/30309949 for details.
    2              0.000004 syn match     rustArrowCharacter display "->"
    2              0.000007 syn match     rustQuestionMark display "?\([a-zA-Z]\+\)\@!"
                            
    2              0.000009 syn match     rustMacro       '\w\(\w\)*!' contains=rustAssert,rustPanic
    2              0.000007 syn match     rustMacro       '#\w\(\w\)*' contains=rustAssert,rustPanic
                            
    2              0.000058 syn match     rustEscapeError   display contained /\\./
    2              0.000016 syn match     rustEscape        display contained /\\\([nrt0\\'"]\|x\x\{2}\)/
    2              0.000012 syn match     rustEscapeUnicode display contained /\\u{\x\{1,6}}/
    2              0.000023 syn match     rustStringContinuation display contained /\\\n\s*/
    2              0.000016 syn region    rustString      start=+b"+ skip=+\\\\\|\\"+ end=+"+ contains=rustEscape,rustEscapeError,rustStringContinuation
    2              0.000018 syn region    rustString      start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=rustEscape,rustEscapeUnicode,rustEscapeError,rustStringContinuation,@Spell
    2              0.000011 syn region    rustString      start='b\?r\z(#*\)"' end='"\z1' contains=@Spell
                            
    2              0.000019 syn region    rustAttribute   start="#!\?\[" end="\]" contains=rustString,rustDerive,rustCommentLine,rustCommentBlock,rustCommentLineDocError,rustCommentBlockDocError
    2              0.000010 syn region    rustDerive      start="derive(" end=")" contained contains=rustDeriveTrait
                            " This list comes from src/libsyntax/ext/deriving/mod.rs
                            " Some are deprecated (Encodable, Decodable) or to be removed after a new snapshot (Show).
    2              0.000010 syn keyword   rustDeriveTrait contained Clone Hash RustcEncodable RustcDecodable Encodable Decodable PartialEq Eq PartialOrd Ord Rand Show Debug Default FromPrimitive Send Sync Copy
                            
                            " Number literals
    2              0.000017 syn match     rustDecNumber   display "\<[0-9][0-9_]*\%([iu]\%(size\|8\|16\|32\|64\|128\)\)\="
    2              0.000011 syn match     rustHexNumber   display "\<0x[a-fA-F0-9_]\+\%([iu]\%(size\|8\|16\|32\|64\|128\)\)\="
    2              0.000009 syn match     rustOctNumber   display "\<0o[0-7_]\+\%([iu]\%(size\|8\|16\|32\|64\|128\)\)\="
    2              0.000009 syn match     rustBinNumber   display "\<0b[01_]\+\%([iu]\%(size\|8\|16\|32\|64\|128\)\)\="
                            
                            " Special case for numbers of the form "1." which are float literals, unless followed by
                            " an identifier, which makes them integer literals with a method call or field access,
                            " or by another ".", which makes them integer literals followed by the ".." token.
                            " (This must go first so the others take precedence.)
    2              0.000011 syn match     rustFloat       display "\<[0-9][0-9_]*\.\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\|\.\)\@!"
                            " To mark a number as a normal float, it must have at least one of the three things integral values don't have:
                            " a decimal point and more numbers; an exponent; and a type suffix.
    2              0.000012 syn match     rustFloat       display "\<[0-9][0-9_]*\%(\.[0-9][0-9_]*\)\%([eE][+-]\=[0-9_]\+\)\=\(f32\|f64\)\="
    2              0.000010 syn match     rustFloat       display "\<[0-9][0-9_]*\%(\.[0-9][0-9_]*\)\=\%([eE][+-]\=[0-9_]\+\)\(f32\|f64\)\="
    2              0.000009 syn match     rustFloat       display "\<[0-9][0-9_]*\%(\.[0-9][0-9_]*\)\=\%([eE][+-]\=[0-9_]\+\)\=\(f32\|f64\)"
                            
                            " For the benefit of delimitMate
    2              0.000022 syn region rustLifetimeCandidate display start=/&'\%(\([^'\\]\|\\\(['nrt0\\\"]\|x\x\{2}\|u{\x\{1,6}}\)\)'\)\@!/ end=/[[:cntrl:][:space:][:punct:]]\@=\|$/ contains=rustSigil,rustLifetime
    2              0.000016 syn region rustGenericRegion display start=/<\%('\|[^[cntrl:][:space:][:punct:]]\)\@=')\S\@=/ end=/>/ contains=rustGenericLifetimeCandidate
    2              0.000015 syn region rustGenericLifetimeCandidate display start=/\%(<\|,\s*\)\@<='/ end=/[[:cntrl:][:space:][:punct:]]\@=\|$/ contains=rustSigil,rustLifetime
                            
                            "rustLifetime must appear before rustCharacter, or chars will get the lifetime highlighting
    2              0.000010 syn match     rustLifetime    display "\'\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*"
    2              0.000009 syn match     rustLabel       display "\'\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*:"
    2              0.000008 syn match   rustCharacterInvalid   display contained /b\?'\zs[\n\r\t']\ze'/
                            " The groups negated here add up to 0-255 but nothing else (they do not seem to go beyond ASCII).
    2              0.000009 syn match   rustCharacterInvalidUnicode   display contained /b'\zs[^[:cntrl:][:graph:][:alnum:][:space:]]\ze'/
    2              0.000014 syn match   rustCharacter   /b'\([^\\]\|\\\(.\|x\x\{2}\)\)'/ contains=rustEscape,rustEscapeError,rustCharacterInvalid,rustCharacterInvalidUnicode
    2              0.000014 syn match   rustCharacter   /'\([^\\]\|\\\(.\|x\x\{2}\|u{\x\{1,6}}\)\)'/ contains=rustEscape,rustEscapeUnicode,rustEscapeError,rustCharacterInvalid
                            
    2              0.000006 syn match rustShebang /\%^#![^[].*/
    2              0.000011 syn region rustCommentLine                                                  start="//"                      end="$"   contains=rustTodo,@Spell
    2              0.000011 syn region rustCommentLineDoc                                               start="//\%(//\@!\|!\)"         end="$"   contains=rustTodo,@Spell
    2              0.000009 syn region rustCommentLineDocError                                          start="//\%(//\@!\|!\)"         end="$"   contains=rustTodo,@Spell contained
    2              0.000016 syn region rustCommentBlock             matchgroup=rustCommentBlock         start="/\*\%(!\|\*[*/]\@!\)\@!" end="\*/" contains=rustTodo,rustCommentBlockNest,@Spell
    2              0.000014 syn region rustCommentBlockDoc          matchgroup=rustCommentBlockDoc      start="/\*\%(!\|\*[*/]\@!\)"    end="\*/" contains=rustTodo,rustCommentBlockDocNest,@Spell
    2              0.000012 syn region rustCommentBlockDocError     matchgroup=rustCommentBlockDocError start="/\*\%(!\|\*[*/]\@!\)"    end="\*/" contains=rustTodo,rustCommentBlockDocNestError,@Spell contained
    2              0.000010 syn region rustCommentBlockNest         matchgroup=rustCommentBlock         start="/\*"                     end="\*/" contains=rustTodo,rustCommentBlockNest,@Spell contained transparent
    2              0.000014 syn region rustCommentBlockDocNest      matchgroup=rustCommentBlockDoc      start="/\*"                     end="\*/" contains=rustTodo,rustCommentBlockDocNest,@Spell contained transparent
    2              0.000011 syn region rustCommentBlockDocNestError matchgroup=rustCommentBlockDocError start="/\*"                     end="\*/" contains=rustTodo,rustCommentBlockDocNestError,@Spell contained transparent
                            " FIXME: this is a really ugly and not fully correct implementation. Most
                            " importantly, a case like ``/* */*`` should have the final ``*`` not being in
                            " a comment, but in practice at present it leaves comments open two levels
                            " deep. But as long as you stay away from that particular case, I *believe*
                            " the highlighting is correct. Due to the way Vim's syntax engine works
                            " (greedy for start matches, unlike Rust's tokeniser which is searching for
                            " the earliest-starting match, start or end), I believe this cannot be solved.
                            " Oh you who would fix it, don't bother with things like duplicating the Block
                            " rules and putting ``\*\@<!`` at the start of them; it makes it worse, as
                            " then you must deal with cases like ``/*/**/*/``. And don't try making it
                            " worse with ``\%(/\@<!\*\)\@<!``, either...
                            
    2              0.000004 syn keyword rustTodo contained TODO FIXME XXX NB NOTE
                            
                            " Folding rules {{{2
                            " Trivial folding rules to begin with.
                            " FIXME: use the AST to make really good folding
    2              0.000008 syn region rustFoldBraces start="{" end="}" transparent fold
                            
                            " Default highlighting {{{1
    2              0.000005 hi def link rustDecNumber       rustNumber
    2              0.000002 hi def link rustHexNumber       rustNumber
    2              0.000002 hi def link rustOctNumber       rustNumber
    2              0.000002 hi def link rustBinNumber       rustNumber
    2              0.000002 hi def link rustIdentifierPrime rustIdentifier
    2              0.000002 hi def link rustTrait           rustType
    2              0.000002 hi def link rustDeriveTrait     rustTrait
                            
    2              0.000003 hi def link rustMacroRepeatCount   rustMacroRepeatDelimiters
    2              0.000002 hi def link rustMacroRepeatDelimiters   Macro
    2              0.000002 hi def link rustMacroVariable Define
    2              0.000002 hi def link rustSigil         StorageClass
    2              0.000002 hi def link rustEscape        Special
    2              0.000002 hi def link rustEscapeUnicode rustEscape
    2              0.000002 hi def link rustEscapeError   Error
    2              0.000002 hi def link rustStringContinuation Special
    2              0.000002 hi def link rustString        String
    2              0.000002 hi def link rustCharacterInvalid Error
    2              0.000002 hi def link rustCharacterInvalidUnicode rustCharacterInvalid
    2              0.000002 hi def link rustCharacter     Character
    2              0.000002 hi def link rustNumber        Number
    2              0.000002 hi def link rustBoolean       Boolean
    2              0.000002 hi def link rustEnum          rustType
    2              0.000002 hi def link rustEnumVariant   rustConstant
    2              0.000002 hi def link rustConstant      Constant
    2              0.000002 hi def link rustSelf          Constant
    2              0.000002 hi def link rustFloat         Float
    2              0.000002 hi def link rustArrowCharacter rustOperator
    2              0.000002 hi def link rustOperator      Operator
    2              0.000002 hi def link rustKeyword       Keyword
    2              0.000002 hi def link rustTypedef       Keyword " More precise is Typedef, but it doesn't feel right for Rust
    2              0.000002 hi def link rustStructure     Keyword " More precise is Structure
    2              0.000002 hi def link rustUnion         rustStructure
    2              0.000002 hi def link rustPubScopeDelim Delimiter
    2              0.000002 hi def link rustPubScopeCrate rustKeyword
    2              0.000002 hi def link rustSuper         rustKeyword
    2              0.000002 hi def link rustReservedKeyword Error
    2              0.000002 hi def link rustRepeat        Conditional
    2              0.000002 hi def link rustConditional   Conditional
    2              0.000002 hi def link rustIdentifier    Identifier
    2              0.000002 hi def link rustCapsIdent     rustIdentifier
    2              0.000002 hi def link rustModPath       Include
    2              0.000002 hi def link rustModPathSep    Delimiter
    2              0.000002 hi def link rustFunction      Function
    2              0.000002 hi def link rustFuncName      Function
    2              0.000002 hi def link rustFuncCall      Function
    2              0.000002 hi def link rustShebang       Comment
    2              0.000002 hi def link rustCommentLine   Comment
    2              0.000002 hi def link rustCommentLineDoc SpecialComment
    2              0.000002 hi def link rustCommentLineDocError Error
    2              0.000002 hi def link rustCommentBlock  rustCommentLine
    2              0.000002 hi def link rustCommentBlockDoc rustCommentLineDoc
    2              0.000002 hi def link rustCommentBlockDocError Error
    2              0.000002 hi def link rustAssert        PreCondit
    2              0.000002 hi def link rustPanic         PreCondit
    2              0.000002 hi def link rustMacro         Macro
    2              0.000002 hi def link rustType          Type
    2              0.000002 hi def link rustTodo          Todo
    2              0.000002 hi def link rustAttribute     PreProc
    2              0.000002 hi def link rustDerive        PreProc
    2              0.000002 hi def link rustDefault       StorageClass
    2              0.000002 hi def link rustStorage       StorageClass
    2              0.000002 hi def link rustObsoleteStorage Error
    2              0.000002 hi def link rustLifetime      Special
    2              0.000002 hi def link rustLabel         Label
    2              0.000002 hi def link rustInvalidBareKeyword Error
    2              0.000002 hi def link rustExternCrate   rustKeyword
    2              0.000002 hi def link rustObsoleteExternMod Error
    2              0.000002 hi def link rustBoxPlacementParens Delimiter
    2              0.000002 hi def link rustQuestionMark  Special
                            
                            " Other Suggestions:
                            " hi rustAttribute ctermfg=cyan
                            " hi rustDerive ctermfg=cyan
                            " hi rustAssert ctermfg=yellow
                            " hi rustPanic ctermfg=red
                            " hi rustMacro ctermfg=magenta
                            
    2              0.000003 syn sync minlines=200
    2              0.000002 syn sync maxlines=500
                            
    2              0.000008 let b:current_syntax = "rust"

FUNCTION  2()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:136
Called 53 times
Total time:   0.002036
 Self time:   0.000732

count  total (s)   self (s)
   53   0.001985   0.000681   call gitgutter#utility#setbufvar(a:buffer, 'path', -2)

FUNCTION  gitgutter#process_buffer()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter.vim:21
Called 52 times
Total time:   0.140425
 Self time:   0.010048

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
   52   0.002893   0.001393   if gitgutter#utility#getbufvar(a:bufnr, 'enabled', -1) == -1
    1   0.000031   0.000010     call gitgutter#utility#setbufvar(a:bufnr, 'enabled', g:gitgutter_enabled)
   52              0.000082   endif
                            
   52   0.041811   0.005780   if gitgutter#utility#is_active(a:bufnr)
                            
   51              0.000298     if has('patch-7.4.1559')
   51              0.000470       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
   51              0.000043     endif
   51   0.093502   0.000677     let how = s:setup_path(a:bufnr, l:Callback)
   51              0.000225     if [how] == ['async']  " avoid string-to-number conversion if how is a number
   51              0.000049       return
                                endif
                            
                                if a:force || s:has_fresh_changes(a:bufnr)
                            
                                  let diff = 'NOT SET'
                                  try
                                    let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter assume unchanged/
                                    call gitgutter#debug#log('Assume unchanged: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
                                  if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
                                  endif
                            
                                endif
    1              0.000001   endif

FUNCTION  copilot#doc#Params()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot/doc.vim:74
Called 15 times
Total time:   0.009418
 Self time:   0.000712

count  total (s)   self (s)
   15              0.000072   let extra = a:0 ? a:1 : {}
   15   0.009159   0.000453   let params = extend({'doc': extend(copilot#doc#Get(), get(extra, 'doc', {}))}, extra, 'keep')
   15              0.000108   let params.textDocument = { 'uri': params.doc.uri, 'version': params.doc.version, 'relativePath': params.doc.relativePath, }
   15              0.000032   let params.position = params.doc.position
   15              0.000016   return params

FUNCTION  <SNR>34_MRUPop()
    Defined: ~/.local/share/nvim/plugged/bufexplorer/plugin/bufexplorer.vim:298
Called 2 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    2              0.000017     call filter(s:MRUList, 'v:val != '.a:bufnr)

FUNCTION  <SNR>41_Trigger()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:424
Called 15 times
Total time:   0.017890
 Self time:   0.000596

count  total (s)   self (s)
   15              0.000201   let timer = get(g:, '_copilot_timer', -1)
   15              0.000043   unlet! g:_copilot_timer
   15              0.000128   if a:bufnr !=# bufnr('') || a:timer isnot# timer || mode() !=# 'i'
                                return
   15              0.000018   endif
   15   0.017439   0.000145   return copilot#Suggest()

FUNCTION  <SNR>77_Callback()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot/agent.vim:548
Called 2 times
Total time:   0.000422
 Self time:   0.000029

count  total (s)   self (s)
    2              0.000009   call remove(a:request.waiting, a:timer)
    2              0.000004   if has_key(a:request, a:type)
    2   0.000405   0.000013     call a:callback(a:request[a:type])
    2              0.000001   endif

FUNCTION  gitgutter#utility#set_repo_path()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:144
Called 51 times
Total time:   0.086737
 Self time:   0.006011

count  total (s)   self (s)
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                              " *               -3 - assume unchanged
                            
   51   0.002346   0.001097   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
   51   0.031479   0.001889   let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' '.g:gitgutter_git_args. ' ls-files -v --error-unmatch --full-name -z -- '. gitgutter#utility#shellescape(s:filename(a:bufnr)))
                            
   51   0.000944   0.000747   if g:gitgutter_async && gitgutter#async#available() && !has('vim_starting')
   51              0.000315     let handler = copy(s:set_path_handler)
   51              0.000155     let handler.continuation = a:continuation
   51   0.051061   0.001370     call gitgutter#async#execute(cmd, a:bufnr, handler)
   51              0.000090     return 'async'
                              endif
                            
                              let listing = gitgutter#utility#system(cmd)
                            
                              if v:shell_error
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                                return
                              endif
                            
                              let listing = s:strip_trailing_new_line(listing)
                              let [status, path] = [listing[0], listing[2:]]
                              if status =~# '[a-z]'
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', -3)
                              else
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', path)
                              endif

FUNCTION  <SNR>29_dir()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:231
Called 102 times
Total time:   0.028158
 Self time:   0.002174

count  total (s)   self (s)
  102   0.028093   0.002109   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  copilot#OnCursorMovedI()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:472
Called 17 times
Total time:   0.013160
 Self time:   0.000198

count  total (s)   self (s)
   17   0.013145   0.000183   return copilot#Schedule()

FUNCTION  copilot#agent#Error()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot/agent.vim:563
Called 15 times
Total time:   0.000170
 Self time:   0.000170

count  total (s)   self (s)
   15              0.000036   if has_key(a:request, 'reject')
   15              0.000052     call add(a:request.reject, a:callback)
                              elseif has_key(a:request, 'error')
                                let a:request.waiting[timer_start(0, function('s:Callback', [a:request, 'error', a:callback]))] = 1
   15              0.000008   endif

FUNCTION  <SNR>41_Running()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:54
Called 35 times
Total time:   0.000245
 Self time:   0.000245

count  total (s)   self (s)
   35              0.000217   return exists('s:agent.job') || exists('s:agent.client_id')

FUNCTION  lightline#update()
    Defined: ~/.local/share/nvim/plugged/lightline.vim/autoload/lightline.vim:13
Called 1 time
Total time:   0.000010
 Self time:   0.000005

count  total (s)   self (s)
    1   0.000010   0.000005   if s:skip() | return | endif
                              if s:_
                                if s:_ == 2 | return | endif
                                call lightline#init()
                                call lightline#colorscheme()
                              endif
                              if s:lightline.enable.statusline
                                let w = winnr()
                                let s = winnr('$') == 1 && w > 0 ? [lightline#statusline(0)] : [lightline#statusline(0), lightline#statusline(1)]
                                for n in range(1, winnr('$'))
                                  call setwinvar(n, '&statusline', s[n!=w])
                                endfor
                              endif

FUNCTION  copilot#agent#LspHandle()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot/agent.vim:387
Called 38 times
Total time:   0.016833
 Self time:   0.001286

count  total (s)   self (s)
   38              0.000413   if !has_key(s:instances, a:agent_id)
                                return
   38              0.000051   endif
   38   0.016204   0.000657   call s:OnResponse(s:instances[a:agent_id], a:response)

FUNCTION  <SNR>86_build_command()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:43
Called 51 times
Total time:   0.000323
 Self time:   0.000323

count  total (s)   self (s)
   51              0.000129   if has('unix')
   51              0.000137     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:101
Called 51 times
Total time:   0.004658
 Self time:   0.000836

count  total (s)   self (s)
   51   0.004620   0.000798   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  <SNR>34_ShouldIgnore()
    Defined: ~/.local/share/nvim/plugged/bufexplorer/plugin/bufexplorer.vim:318
Called 2 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
                                " Ignore temporary buffers with buftype set.
    2              0.000011     if empty(getbufvar(a:buf, "&buftype")) == 0
    1              0.000001         return 1
    1              0.000001     endif
                            
                                " Ignore buffers with no name.
    1              0.000003     if empty(bufname(a:buf)) == 1
                                    return 1
    1              0.000000     endif
                            
                                " Ignore the BufExplorer buffer.
    1              0.000004     if fnamemodify(bufname(a:buf), ":t") == s:name
                                    return 1
    1              0.000000     endif
                            
                                " Ignore any buffers in the exclude list.
    1              0.000003     if index(s:MRU_Exclude_List, bufname(a:buf)) >= 0
                                    return 1
    1              0.000001     endif
                            
                                " Else return 0 to indicate that the buffer was not ignored.
    1              0.000001     return 0

FUNCTION  15()
    Defined: /usr/local/Cellar/neovim/0.8.1/share/nvim/runtime/autoload/provider/clipboard.vim:153
Called 1 time
Total time:   0.027914
 Self time:   0.000139

count  total (s)   self (s)
    1              0.000010   if type(s:paste[a:reg]) == v:t_func
                                return s:paste[a:reg]()
    1              0.000006   elseif s:selections[a:reg].owner > 0
                                return s:selections[a:reg].data
    1              0.000001   end
                            
    1   0.027825   0.000050   let clipboard_data = s:try_cmd(s:paste[a:reg])
    1              0.000052   if match(&clipboard, '\v(unnamed|unnamedplus)') >= 0 && type(clipboard_data) == v:t_list && get(s:selections[a:reg].data, 0, []) ==# clipboard_data
                                " When system clipboard return is same as our cache return the cache
                                " as it contains regtype information
    1              0.000003     return s:selections[a:reg].data
                              end
                              return clipboard_data

FUNCTION  16()
    Defined: /usr/local/Cellar/neovim/0.8.1/share/nvim/runtime/autoload/provider/clipboard.vim:171
Called 2 times
Total time:   0.040289
 Self time:   0.000189

count  total (s)   self (s)
    2              0.000005   if a:reg == '"'
                                call s:clipboard.set(a:lines,a:regtype,'+')
                                if s:copy['*'] != s:copy['+']
                                  call s:clipboard.set(a:lines,a:regtype,'*')
                                end
                                return 0
    2              0.000001   end
                            
    2              0.000009   if type(s:copy[a:reg]) == v:t_func
                                call s:copy[a:reg](a:lines, a:regtype)
                                return 0
    2              0.000001   end
                            
    2              0.000003   if s:cache_enabled == 0
    2   0.040199   0.000099     call s:try_cmd(s:copy[a:reg], a:lines)
                                "Cache it anyway we can compare it later to get regtype of the yank
    2              0.000022     let s:selections[a:reg] = copy(s:selection)
    2              0.000007     let s:selections[a:reg].data = [a:lines, a:regtype]
    2              0.000002     return 0
                              end
                            
                              if s:selections[a:reg].owner > 0
                                let prev_job = s:selections[a:reg].owner
                              end
                              let s:selections[a:reg] = copy(s:selection)
                              let selection = s:selections[a:reg]
                              let selection.data = [a:lines, a:regtype]
                              let selection.argv = s:copy[a:reg]
                              let selection.detach = s:cache_enabled
                              let selection.cwd = "/"
                              let jobid = jobstart(selection.argv, selection)
                              if jobid > 0
                                call jobsend(jobid, a:lines)
                                call jobclose(jobid, 'stdin')
                                " xclip does not close stdout when receiving input via stdin
                                if selection.argv[0] ==# 'xclip'
                                  call jobclose(jobid, 'stdout')
                                endif
                                let selection.owner = jobid
                                let ret = 1
                              else
                                echohl WarningMsg
                                echomsg 'clipboard: failed to execute: '.(s:copy[a:reg])
                                echohl None
                                let ret = 1
                              endif
                            
                              " The previous provider instance should exit when the new one takes
                              " ownership, but kill it to be sure we don't fill up the job table.
                              if exists('prev_job')
                                call timer_start(1000, {... -> jobwait([prev_job], 0)[0] == -1 && jobstop(prev_job)})
                              endif
                            
                              return ret

FUNCTION  <SNR>86_on_stdout_nvim()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:56
Called 51 times
Total time:   0.000948
 Self time:   0.000948

count  total (s)   self (s)
   51              0.000305   if empty(self.stdoutbuffer)
   51              0.000173     let self.stdoutbuffer = a:data
                              else
                                let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
   51              0.000087   endif

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:181
Called 51 times
Total time:   0.021443
 Self time:   0.005697

count  total (s)   self (s)
   51   0.012130   0.005021   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
   51   0.009261   0.000624   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  lightline#mode()
    Defined: ~/.local/share/nvim/plugged/lightline.vim/autoload/lightline.vim:213
Called 503 times
Total time:   0.002703
 Self time:   0.002703

count  total (s)   self (s)
  503              0.002368   return get(s:lightline.mode_map, mode(), '')

FUNCTION  <SNR>34_AddBufToCurrentTab()
    Defined: ~/.local/share/nvim/plugged/bufexplorer/plugin/bufexplorer.vim:227
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000009     if index(t:bufexp_buf_list, a:bufnr) == -1
    1              0.000002         call add(t:bufexp_buf_list, a:bufnr)
    2              0.000001     endif

FUNCTION  <SNR>34_MRUPush()
    Defined: ~/.local/share/nvim/plugged/bufexplorer/plugin/bufexplorer.vim:303
Called 2 times
Total time:   0.000076
 Self time:   0.000032

count  total (s)   self (s)
                                " Skip temporary buffer with buftype set. Don't add the BufExplorer window
                                " to the list.
    2   0.000048   0.000015     if s:ShouldIgnore(a:buf) == 1
    1              0.000001         return
    1              0.000001     endif
                            
                                " Remove the buffer number from the list if it already exists.
    1   0.000017   0.000007     call s:MRUPop(a:buf)
                            
                                " Add the buffer number to the head of the list.
    1              0.000003     call insert(s:MRUList, a:buf)

FUNCTION  <SNR>68_setup_path()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter.vim:169
Called 51 times
Total time:   0.092825
 Self time:   0.001430

count  total (s)   self (s)
   51   0.005387   0.000730   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
   51   0.087361   0.000624   return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  <SNR>41_StatusNotification()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:41
Called 25 times
Total time:   0.000501
 Self time:   0.000501

count  total (s)   self (s)
   25              0.000208   let status = get(a:params, 'status', '')
   25              0.000069   if status ==? 'error'
                                let s:agent_error = a:params.message
   25              0.000022   else
   25              0.000068     unlet! s:agent_error
   25              0.000016   endif

FUNCTION  <SNR>77_LspRequest()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot/agent.vim:365
Called 15 times
Total time:   0.005010
 Self time:   0.003792

count  total (s)   self (s)
   15   0.003632   0.003436   let id = v:lua.require'_copilot'.lsp_request(self.id, a:method, a:params)
   15              0.000057   if id isnot# v:null
   15   0.001300   0.000278     return call('s:SetUpRequest', [self, id, a:method, a:params] + a:000)
                              endif
                              if has_key(self, 'client_id')
                                call copilot#agent#LspExit(self.client_id, -1, -1)
                              endif
                              throw 'copilot#agent: LSP client not available'

FUNCTION  lightline#link()
    Defined: ~/.local/share/nvim/plugged/lightline.vim/autoload/lightline.vim:218
Called 503 times
Total time:   0.026059
 Self time:   0.026059

count  total (s)   self (s)
  503              0.006374   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
  503              0.001289   if s:mode ==# mode
  481              0.001128     return ''
   22              0.000029   endif
   22              0.000052   let s:mode = mode
   22              0.000085   if !has_key(s:highlight, mode)
                                call lightline#highlight(mode)
   22              0.000014   endif
   22              0.000367   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
   66              0.000301   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
  242              0.000696     for [i, t] in map(range(0, l), '[v:val, 0]') + types
  198              0.000252       if i != l
  154              0.001267         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
  198              0.000118       endif
 1100              0.002663       for [j, s] in map(range(0, l), '[v:val, 0]') + types
  902              0.001675         if i + 1 == j || t || s && i != l
  418              0.003454           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
  902              0.000520         endif
 1100              0.000623       endfor
  242              0.000237     endfor
   66              0.000074   endfor
   22              0.000125   exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
   22              0.000031   return ''

FUNCTION  copilot#Suggest()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:415
Called 15 times
Total time:   0.017294
 Self time:   0.000430

count  total (s)   self (s)
   15              0.000021   try
   15   0.017166   0.000302     call copilot#Complete(function('s:HandleTriggerResult'), function('s:HandleTriggerResult'))
                              catch
                                call copilot#logger#Exception()
   15              0.000017   endtry
   15              0.000015   return ''

FUNCTION  <SNR>28_on_bufenter()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/plugin/gitgutter.vim:236
Called 1 time
Total time:   0.000248
 Self time:   0.000045

count  total (s)   self (s)
    1   0.000012   0.000006   call gitgutter#setup_maps()
                            
                              " To keep vim's start-up fast, do not process the buffer when vim is starting.
                              " Instead process it a short time later.  Normally we would rely on our
                              " CursorHold autocommand to handle this but it turns out CursorHold is not
                              " guaranteed to fire if the user has not typed anything yet; so set up a
                              " timer instead.  The disadvantage is that if CursorHold does fire, the
                              " plugin will do a round of unnecessary work; but since there will not have
                              " been any changes to the buffer since the first round, the second round
                              " will be cheap.
    1              0.000005   if has('vim_starting') && !$VIM_GITGUTTER_TEST
                                if exists('*timer_start') && has('lambda')
                                  call s:next_tick("call gitgutter#process_buffer(+".bufnr('').", 0)")
                                else
                                  call gitgutter#process_buffer(bufnr(''), 0)
                                endif
                                return
    1              0.000000   endif
                            
    1              0.000003   if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
                                let t:gitgutter_didtabenter = 0
                                call gitgutter#all(!g:gitgutter_terminal_reports_focus)
    1              0.000000   else
    1   0.000206   0.000009     call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
    1              0.000001   endif

FUNCTION  <SNR>29_not_git_dir()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:58
Called 51 times
Total time:   0.020593
 Self time:   0.001072

count  total (s)   self (s)
   51   0.020554   0.001033   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  <SNR>41_Start()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:58
Called 35 times
Total time:   0.000550
 Self time:   0.000305

count  total (s)   self (s)
   35   0.000482   0.000237   if s:Running()
   35              0.000036     return
                              endif
                              let s:agent = copilot#agent#New({'notifications': { 'statusNotification': function('s:StatusNotification'), 'PanelSolution': function('copilot#panel#Solution'), 'PanelSolutionsDone': function('copilot#panel#SolutionsDone'), }, 'editorConfiguration' : s:EditorConfiguration()})

FUNCTION  <SNR>77_RequestAgent()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot/agent.vim:79
Called 15 times
Total time:   0.000147
 Self time:   0.000147

count  total (s)   self (s)
   15              0.000123   return get(s:instances, self.agent_id, v:null)

FUNCTION  <SNR>34_ActivateBuffer()
    Defined: ~/.local/share/nvim/plugged/bufexplorer/plugin/bufexplorer.vim:285
Called 2 times
Total time:   0.000258
 Self time:   0.000058

count  total (s)   self (s)
    2              0.000007     let _bufnr = bufnr("%")
    2   0.000159   0.000035     call s:UpdateTabBufData(_bufnr)
    2   0.000090   0.000014     call s:MRUPush(_bufnr)

FUNCTION  copilot#agent#Cancel()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot/agent.vim:542
Called 30 times
Total time:   0.002841
 Self time:   0.000543

count  total (s)   self (s)
   30              0.000271   if type(a:request) == type({}) && has_key(a:request, 'Cancel')
   15   0.002465   0.000167     call a:request.Cancel()
   30              0.000024   endif

FUNCTION  <SNR>29_filename()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:236
Called 51 times
Total time:   0.006782
 Self time:   0.000567

count  total (s)   self (s)
   51   0.006753   0.000538   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  <SNR>34_DeactivateBuffer()
    Defined: ~/.local/share/nvim/plugged/bufexplorer/plugin/bufexplorer.vim:292
Called 1 time
Total time:   0.000018
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000005     let _bufnr = str2nr(expand("<abuf>"))
    1   0.000012   0.000005     call s:MRUPop(_bufnr)

FUNCTION  <SNR>46_Remove_Matches()
    Defined: /usr/local/Cellar/neovim/0.8.1/share/nvim/runtime/plugin/matchparen.vim:196
Called 110 times
Total time:   0.002985
 Self time:   0.002985

count  total (s)   self (s)
  110              0.001962   if exists('w:paren_hl_on') && w:paren_hl_on
   22              0.000108     silent! call matchdelete(3)
   22              0.000087     let w:paren_hl_on = 0
  110              0.000138   endif

FUNCTION  <SNR>77_OnResponse()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot/agent.vim:235
Called 53 times
Total time:   0.016358
 Self time:   0.003103

count  total (s)   self (s)
   53              0.000191   let response = a:response
   53              0.000209   let id = get(response, 'id', v:null)
   53              0.000131   if has_key(response, 'method')
   38              0.000132     let params = get(response, 'params', v:null)
   38              0.000088     if empty(id)
   38              0.000127       if has_key(a:agent.notifications, response.method)
   25              0.000264         call timer_start(0, { _ -> a:agent.notifications[response.method](params) })
   13              0.000032       elseif response.method ==# 'LogMessage'
   13   0.013423   0.000168         call copilot#logger#Raw(get(params, 'level', 3), get(params, 'message', ''))
   38              0.000028       endif
                                elseif has_key(a:agent.methods, response.method)
                                  call timer_start(0, function('s:DispatchMessage', [a:agent, a:agent.methods[response.method], id, params]))
                                else
                                  return s:Send(a:agent, {"id": id, "error": {"code": -32700, "message": "Method not found: " . response.method}})
   38              0.000025     endif
   38              0.000032     return
   15              0.000008   endif
   15              0.000065   if !has_key(a:agent.requests, id)
   13              0.000010     return
    2              0.000001   endif
    2              0.000007   let request = remove(a:agent.requests, id)
    2              0.000004   if request.status ==# 'canceled'
                                return
    2              0.000001   endif
    2              0.000005   let request.waiting = {}
    2              0.000004   let resolve = remove(request, 'resolve')
    2              0.000004   let reject = remove(request, 'reject')
    2              0.000003   if has_key(response, 'result')
    2              0.000003     let request.status = 'success'
    2              0.000003     let request.result = response.result
    4              0.000008     for Cb in resolve
    2              0.000022       let request.waiting[timer_start(0, function('s:Callback', [request, 'result', Cb]))] = 1
    4              0.000003     endfor
                              else
                                let request.status = 'error'
                                let request.error = response.error
                                for Cb in reject
                                  let request.waiting[timer_start(0, function('s:Callback', [request, 'error', Cb]))] = 1
                                endfor
    2              0.000001   endif

FUNCTION  gitgutter#debug#log()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim:70
Called 51 times
Total time:   0.002576
 Self time:   0.002576

count  total (s)   self (s)
   51              0.000108   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
   51              0.000044   endif

FUNCTION  <SNR>6_SynSet()
    Defined: /usr/local/Cellar/neovim/0.8.1/share/nvim/runtime/syntax/synload.vim:26
Called 1 time
Total time:   0.001002
 Self time:   0.001002

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    1              0.000003   syn clear
    1              0.000003   if exists("b:current_syntax")
                                unlet b:current_syntax
    1              0.000001   endif
                            
    1              0.000004   0verbose let s = expand("<amatch>")
    1              0.000001   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    1              0.000001   elseif s == "OFF"
                                let s = ""
    1              0.000000   endif
                            
    1              0.000001   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
    2              0.000009     for name in split(s, '\.')
    1              0.000002       if !empty(name)
    1              0.000534         exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    1              0.000422         exe "runtime! syntax/" . name . ".lua syntax/" . name . "/*.lua"
    1              0.000001       endif
    2              0.000002     endfor
    1              0.000001   endif

FUNCTION  copilot#OnInsertLeave()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:448
Called 3 times
Total time:   0.002277
 Self time:   0.000035

count  total (s)   self (s)
    3   0.002274   0.000032   return copilot#Clear()

FUNCTION  copilot#Complete()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:168
Called 15 times
Total time:   0.016864
 Self time:   0.001315

count  total (s)   self (s)
   15              0.000059   if exists('g:_copilot_timer')
                                call timer_stop(remove(g:, '_copilot_timer'))
   15              0.000011   endif
   15   0.009608   0.000189   let params = copilot#doc#Params()
   15              0.000062   if !exists('b:_copilot.params') || b:_copilot.params !=# params
   15   0.005889   0.000168     let b:_copilot = {'params': params, 'first': copilot#Request('getCompletions', params)}
   15              0.000207     let g:_copilot_last = b:_copilot
   15              0.000011   endif
   15              0.000038   let completion = b:_copilot.first
   15              0.000017   if !a:0
                                return completion.Await()
   15              0.000010   else
   15   0.000469   0.000229     call copilot#agent#Result(completion, a:1)
   15              0.000021     if a:0 > 1
   15   0.000274   0.000104       call copilot#agent#Error(completion, a:2)
   15              0.000009     endif
   15              0.000007   endif

FUNCTION  copilot#doc#Get()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot/doc.vim:54
Called 15 times
Total time:   0.008706
 Self time:   0.007174

count  total (s)   self (s)
   15              0.000126   let absolute = tr(@%, s:slash, '/')
   15              0.000315   if absolute !~# '^\a\+:\|^/\|^$' && &buftype =~# '^\%(nowrite\)\=$'
   15              0.005565     let absolute = substitute(tr(getcwd(), s:slash, '/'), '/\=$', '/', '') . absolute
   15              0.000042   endif
   15   0.001772   0.000454   let doc = { 'uri': bufnr(''), 'version': getbufvar('', 'changedtick'), 'relativePath': s:RelativePath(absolute), 'insertSpaces': &expandtab ? v:true : v:false, 'tabSize': shiftwidth(), 'indentSize': shiftwidth(), }
   15              0.000052   let line = getline('.')
   15              0.000230   let col_byte = col('.') - (mode() =~# '^[iR]' || empty(line))
   15   0.000426   0.000212   let col_utf16 = copilot#doc#UTF16Width(strpart(line, 0, col_byte))
   15              0.000098   let doc.position = {'line': line('.') - 1, 'character': col_utf16}
   15              0.000021   return doc

FUNCTION  <SNR>40_Event()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/plugin/copilot.vim:45
Called 23 times
Total time:   0.018982
 Self time:   0.000685

count  total (s)   self (s)
   23              0.000072   try
   23   0.018743   0.000446     call call('copilot#On' . a:type, [])
                              catch
                                call copilot#logger#Exception()
   23              0.000025   endtry

FUNCTION  <SNR>69_skip()
    Defined: ~/.local/share/nvim/plugged/lightline.vim/autoload/lightline.vim:30
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004     return win_gettype() ==# 'popup' || win_gettype() ==# 'autocmd'

FUNCTION  <SNR>41_UpdatePreview()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:348
Called 25 times
Total time:   0.008597
 Self time:   0.004448

count  total (s)   self (s)
   25              0.000033   try
   25   0.003748   0.000487     let [text, outdent, delete, uuid] = s:SuggestionTextWithAdjustments()
   25              0.000289     let text = split(text, "\n", 1)
   25              0.000099     if empty(text[-1])
   25              0.000104       call remove(text, -1)
   25              0.000022     endif
   25              0.000104     if s:dest > 0
                                  call s:WindowPreview(text, outdent, delete)
   25              0.000024     endif
   25              0.000080     if empty(text) || s:dest >= 0
   25   0.001224   0.000336       return s:ClearPreview()
                                endif
                                if exists('b:_copilot.cycling_callbacks')
                                  let annot = '(1/…)'
                                elseif exists('b:_copilot.cycling')
                                  let annot = '(' . (b:_copilot.choice + 1) . '/' . len(b:_copilot.suggestions) . ')'
                                else
                                  let annot = ''
                                endif
                                call s:ClearPreview()
                                if s:has_nvim_ghost_text
                                  let data = {'id': 1}
                                  let data.virt_text_win_col = virtcol('.') - 1
                                  let data.virt_text = [[text[0] . repeat(' ', delete - len(text[0])), s:hlgroup]]
                                  if len(text) > 1
                                    let data.virt_lines = map(text[1:-1], { _, l -> [[l, s:hlgroup]] })
                                    if !empty(annot)
                                      let data.virt_lines[-1] += [[' '], [annot, s:annot_hlgroup]]
                                    endif
                                  elseif len(annot)
                                    let data.virt_text += [[' '], [annot, s:annot_hlgroup]]
                                  endif
                                  let data.hl_mode = 'combine'
                                  call nvim_buf_set_extmark(0, copilot#NvimNs(), line('.')-1, col('.')-1, data)
                                else
                                  let trail = strpart(getline('.'), col('.') - 1)
                                  while !empty(trail) && trail[-1] ==# text[0][-1]
                                    let trail = trail[:-2]
                                    let text[0] = text[0][:-2]
                                  endwhile
                                  call prop_add(line('.'), col('.'), {'type': s:hlgroup, 'text': text[0]})
                                  for line in text[1:]
                                    call prop_add(line('.'), 0, {'type': s:hlgroup, 'text_align': 'below', 'text': line})
                                  endfor
                                  if !empty(annot)
                                    call prop_add(line('.'), col('$'), {'type': s:annot_hlgroup, 'text': ' ' . annot})
                                  endif
                                endif
                                if uuid !=# get(s:, 'uuid', '')
                                  let s:uuid = uuid
                                  call copilot#Request('notifyShown', {'uuid': uuid})
                                endif
                              catch
                                return copilot#logger#Exception()
   25              0.000032   endtry

FUNCTION  copilot#Request()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:90
Called 15 times
Total time:   0.005721
 Self time:   0.000369

count  total (s)   self (s)
   15   0.000425   0.000084   let agent = copilot#Agent()
   15   0.005283   0.000273   return call(agent.Request, [a:method, a:params] + a:000)

FUNCTION  <SNR>77_SetUpRequest()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot/agent.vim:87
Called 15 times
Total time:   0.001023
 Self time:   0.001023

count  total (s)   self (s)
   15              0.000409   let request = { 'agent_id': a:agent.id, 'id': a:id, 'method': a:method, 'params': a:params, 'Agent': function('s:RequestAgent'), 'Wait': function('s:RequestWait'), 'Await': function('s:RequestAwait'), 'Cancel': function('s:RequestCancel'), 'resolve': [], 'reject': [], 'status': 'running'}
   15              0.000076   let a:agent.requests[a:id] = request
   15              0.000047   let args = a:000[2:-1]
   15              0.000033   if len(args)
                                if !empty(a:1)
                                  call add(request.resolve, { v -> call(a:1, [v] + args)})
                                endif
                                if !empty(a:2)
                                  call add(request.reject, { v -> call(a:2, [v] + args)})
                                endif
                                return request
   15              0.000010   endif
   15              0.000031   if a:0 && !empty(a:1)
                                call add(request.resolve, a:1)
   15              0.000008   endif
   15              0.000029   if a:0 > 1 && !empty(a:2)
                                call add(request.reject, a:2)
   15              0.000007   endif
   15              0.000018   return request

FUNCTION  <SNR>34_UpdateTabBufData()
    Defined: ~/.local/share/nvim/plugged/bufexplorer/plugin/bufexplorer.vim:258
Called 2 times
Total time:   0.000123
 Self time:   0.000062

count  total (s)   self (s)
                                " The first time we add a tab, Vim uses the current buffer
                                " as its starting page even though we are about to edit a
                                " new page, and another BufEnter for the new page is triggered
                                " later. Use this first BufEnter to initialize the list of
                                " buffers, but don't add the buffer number to the list if
                                " it is already associated with another tab
                                "
                                " Unfortunately, this doesn't work right when the first
                                " buffer opened in the tab should be associated with it,
                                " such as when 'tab split +buffer N' is used
    2              0.000008     if !exists("t:bufexp_buf_list")
                                    let t:bufexp_buf_list = []
                            
                                    if s:AssociatedTab(a:bufnr) != -1
                                        return
                                    endif
    2              0.000001     endif
                            
    2   0.000030   0.000015     call s:AddBufToCurrentTab(a:bufnr)
                            
    2              0.000002     if g:bufExplorerOnlyOneTab
    2   0.000058   0.000013         call s:RemoveBufFromOtherTabs(a:bufnr)
    2              0.000001     endif

FUNCTION  <SNR>41_ClearPreview()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:339
Called 25 times
Total time:   0.000888
 Self time:   0.000647

count  total (s)   self (s)
   25              0.000063   if s:has_nvim_ghost_text
   25   0.000539   0.000298     call nvim_buf_del_extmark(0, copilot#NvimNs(), 1)
                              elseif s:has_vim_ghost_text
                                call prop_remove({'type': s:hlgroup, 'all': v:true})
                                call prop_remove({'type': s:annot_hlgroup, 'all': v:true})
   25              0.000019   endif

FUNCTION  <SNR>86_on_stderr_nvim()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:66
Called 104 times
Total time:   0.003806
 Self time:   0.001770

count  total (s)   self (s)
  104              0.000874   if a:data != ['']  " With Neovim there is always [''] reported on stderr.
   53   0.002483   0.000447     call self.handler.err(self.buffer)
  104              0.000072   endif

FUNCTION  <SNR>77_AgentStartupError()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot/agent.vim:490
Called 20 times
Total time:   0.000412
 Self time:   0.000412

count  total (s)   self (s)
   20              0.000175   while has_key(self, 'job') && !has_key(self, 'startup_error') && !has_key(self, 'capabilities')
                                sleep 10m
   20              0.000038   endwhile
   20              0.000087   if has_key(self, 'capabilities') || has_key(self, 'client_id')
   20              0.000024     return ''
                              else
                                return get(self, 'startup_error', 'Something unexpected went wrong spawning the agent')
                              endif

FUNCTION  <SNR>82_RelativePath()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot/doc.vim:36
Called 15 times
Total time:   0.001318
 Self time:   0.001318

count  total (s)   self (s)
   15              0.000058   if exists('b:copilot_relative_path')
                                return b:copilot_relative_path
   15              0.000036   elseif exists('b:copilot_root')
                                let root = b:copilot_root
   15              0.000076   elseif len(get(b:, 'projectionist', {}))
                                let root = sort(keys(b:projectionist), { a, b -> a < b })[0]
   15              0.000010   else
   15              0.000566     let root = getcwd()
   15              0.000017   endif
   15              0.000099   let root = tr(root, s:slash, '/') . '/'
   15              0.000201   if strpart(tr(a:absolute, 'A-Z', 'a-z'), 0, len(root)) ==# tr(root, 'A-Z', 'a-z')
   15              0.000058     return strpart(a:absolute, len(root))
                              else
                                return fnamemodify(a:absolute, ':t')
                              endif

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:72
Called 153 times
Total time:   0.015911
 Self time:   0.015911

count  total (s)   self (s)
  153              0.015463   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
  153              0.000292     return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
                                return shellescape(a:arg)
                              endif

FUNCTION  gitgutter#async#available()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:11
Called 51 times
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
   51              0.000157   return s:available

FUNCTION  copilot#Agent()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:77
Called 35 times
Total time:   0.000898
 Self time:   0.000348

count  total (s)   self (s)
   35   0.000821   0.000270   call s:Start()
   35              0.000048   return s:agent

FUNCTION  <SNR>41_HideDuringCompletion()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:189
Called 19 times
Total time:   0.000197
 Self time:   0.000197

count  total (s)   self (s)
   19              0.000177   return get(g:, 'copilot_hide_during_completion', 1)

FUNCTION  copilot#OnInsertEnter()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:452
Called 3 times
Total time:   0.002859
 Self time:   0.001272

count  total (s)   self (s)
    3   0.000125   0.000067   let s:is_mapped = copilot#IsMapped()
    3              0.001082   let s:dest = bufnr('^copilot://$')
    3              0.000022   if s:dest > 0 && bufwinnr(s:dest) < 0
                                let s:dest = -1
    3              0.000004   endif
    3              0.000009   if s:dest < 0 && !s:has_ghost_text
                                let s:dest = 0
    3              0.000002   endif
    3   0.001595   0.000065   return copilot#Schedule()

FUNCTION  copilot#logger#Raw()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot/logger.vim:18
Called 13 times
Total time:   0.013255
 Self time:   0.013209

count  total (s)   self (s)
   13              0.000215   if $COPILOT_AGENT_VERBOSE !~# '^\%(1\|true\)$' && a:level < 1
                                return
   13              0.000009   endif
   13              0.000139   let lines = type(a:message) == v:t_list ? copy(a:message) : split(a:message, "\n", 1)
   13              0.000029   try
   13              0.000852     if !filewritable(s:log_file)
                                  return
   13              0.000009     endif
   13   0.000275   0.000229     call map(lines, { k, L -> type(L) == v:t_func ? call(L, []) : L })
   13              0.011562     call writefile(lines, s:log_file, 'a')
                              catch
   13              0.000020   endtry

FUNCTION  <SNR>41_HandleTriggerResult()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:406
Called 2 times
Total time:   0.000392
 Self time:   0.000031

count  total (s)   self (s)
    2              0.000005   if !exists('b:_copilot')
                                return
    2              0.000001   endif
    2              0.000007   let b:_copilot.suggestions = get(a:result, 'completions', [])
    2              0.000003   let b:_copilot.choice = 0
    2   0.000373   0.000012   call s:UpdatePreview()

FUNCTION  <SNR>46_Highlight_Matching_Pair()
    Defined: /usr/local/Cellar/neovim/0.8.1/share/nvim/runtime/plugin/matchparen.vim:39
Called 110 times
Total time:   0.023295
 Self time:   0.020310

count  total (s)   self (s)
                              " Remove any previous match.
  110   0.005410   0.002425   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  110              0.000614   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
  110              0.000067   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  110              0.000471   let c_lnum = line('.')
  110              0.000319   let c_col = col('.')
  110              0.000161   let before = 0
                            
  110              0.000389   let text = getline(c_lnum)
  110              0.002168   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  110              0.000306   if empty(matches)
                                let [c_before, c] = ['', '']
  110              0.000096   else
  110              0.000592     let [c_before, c] = matches[1:2]
  110              0.000608   endif
  110              0.002017   let plist = split(&matchpairs, '.\zs[:,]')
  110              0.000457   let i = index(plist, c)
  110              0.000169   if i < 0
                                " not found, in Insert mode try character before the cursor
   93              0.000439     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   30              0.000108       let before = strlen(c_before)
   30              0.000057       let c = c_before
   30              0.000084       let i = index(plist, c)
   93              0.000069     endif
   93              0.000113     if i < 0
                                  " not found, nothing to do
   89              0.000110       return
    4              0.000003     endif
   21              0.000014   endif
                            
                              " Figure out the arguments for searchpairpos().
   21              0.000032   if i % 2 == 0
   10              0.000016     let s_flags = 'nW'
   10              0.000022     let c2 = plist[i + 1]
   11              0.000008   else
   11              0.000023     let s_flags = 'nbW'
   11              0.000021     let c2 = c
   11              0.000033     let c = plist[i - 1]
   21              0.000014   endif
   21              0.000031   if c == '['
    8              0.000009     let c = '\['
    8              0.000008     let c2 = '\]'
   21              0.000012   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   21              0.000028   if before > 0
    4              0.000020     let has_getcurpos = exists("*getcurpos")
    4              0.000006     if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
    4              0.000015       let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
    4              0.000003     endif
    4              0.000019     call cursor(c_lnum, c_col - before)
   21              0.000012   endif
                            
   21              0.000141   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
   21              0.000015   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
   21              0.000109     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
   21              0.000026     try
   21              0.000441       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
   21              0.000024     endtry
   21              0.000014   endif
                            
                              " Limit the search to lines visible in the window.
   21              0.000422   let stoplinebottom = line('w$')
   21              0.000065   let stoplinetop = line('w0')
   21              0.000032   if i % 2 == 0
   10              0.000025     let stopline = stoplinebottom
   11              0.000007   else
   11              0.000031     let stopline = stoplinetop
   21              0.000012   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   21              0.000074   if mode() == 'i' || mode() == 'R'
    8              0.000054     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
   13              0.000007   else
   13              0.000068     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
   21              0.000012   endif
   21              0.000017   try
   21              0.001267     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
   21              0.000022   endtry
                            
   21              0.000032   if before > 0
    4              0.000006     if has_getcurpos
    4              0.000018       call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
    4              0.000003     endif
   21              0.000013   endif
                            
                              " If a match is found setup match highlighting.
   21              0.000086   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
   21              0.000069     if exists('*matchaddpos')
   21              0.000236       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
   21              0.000014     endif
   21              0.000050     let w:paren_hl_on = 1
   21              0.000014   endif

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:9
Called 105 times
Total time:   0.002573
 Self time:   0.002573

count  total (s)   self (s)
  105              0.000450   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
  105              0.000477   let ggvars = getbufvar(buffer, 'gitgutter')
  105              0.000324   if type(ggvars) == type('')
    1              0.000002     unlet ggvars
    1              0.000002     let ggvars = {}
    1              0.000004     call setbufvar(buffer, 'gitgutter', ggvars)
  105              0.000092   endif
  105              0.000335   let ggvars[a:varname] = a:val

FUNCTION  <SNR>41_BufferDisabled()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:142
Called 20 times
Total time:   0.001367
 Self time:   0.001367

count  total (s)   self (s)
   20              0.000090   if exists('b:copilot_disabled')
                                return empty(b:copilot_disabled) ? 0 : 3
   20              0.000016   endif
   20              0.000055   if exists('b:copilot_enabled')
                                return empty(b:copilot_enabled) ? 4 : 0
   20              0.000013   endif
   20              0.000345   let short = empty(&l:filetype) ? '.' : split(&l:filetype, '\.', 1)[0]
   20              0.000117   let config = get(g:, 'copilot_filetypes', {})
   20              0.000138   if type(config) == v:t_dict && has_key(config, &l:filetype)
                                return empty(config[&l:filetype])
   20              0.000063   elseif has_key(config, short)
                                return empty(config[short])
   20              0.000046   elseif has_key(config, '*')
                                return empty(config['*'])
   20              0.000018   else
   20              0.000102     return get(s:filetype_defaults, short, 1) == 0 ? 2 : 0
                              endif

FUNCTION  <SNR>47_LocalBrowse()
    Defined: /usr/local/Cellar/neovim/0.8.1/share/nvim/runtime/plugin/netrwPlugin.vim:102
Called 1 time
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
    1              0.000002   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
    1              0.000000   endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
    1              0.000003   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
    1              0.000004   elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               " Jul 13, 2021: for whatever reason, preceding the following call with
                               " a   sil!  causes an unbalanced if-endif vim error
                               call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
    1              0.000000   else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
    1              0.000000   endif
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  <SNR>29_is_file_buffer()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:62
Called 52 times
Total time:   0.000452
 Self time:   0.000452

count  total (s)   self (s)
   52              0.000413   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  <SNR>34_RemoveBufFromOtherTabs()
    Defined: ~/.local/share/nvim/plugged/bufexplorer/plugin/bufexplorer.vim:207
Called 2 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    4              0.000011     for tab in range(1, tabpagenr('$'))
    2              0.000003         if tab == tabpagenr()
    2              0.000002             continue
                                    endif
                            
                                    let list = gettabvar(tab, 'bufexp_buf_list', [])
                                    let idx = index(list, a:bufnr)
                                    if idx == -1
                                        continue
                                    endif
                            
                                    call remove(list, idx)
                                    call settabvar(tab, 'bufexp_buf_list', list)
    2              0.000004     endfor

FUNCTION  <SNR>84_get_line_trimmed()
    Defined: /usr/local/Cellar/neovim/0.8.1/share/nvim/runtime/indent/rust.vim:37
Called 3 times
Total time:   0.000302
 Self time:   0.000302

count  total (s)   self (s)
                            	" Get the line and remove a trailing comment.
                            	" Use syntax highlighting attributes when possible.
                            	" NOTE: this is not accurate; /* */ or a line continuation could trick it
    3              0.000019 	let line = getline(a:lnum)
    3              0.000017 	let line_len = strlen(line)
    3              0.000018 	if has('syntax_items')
                            		" If the last character in the line is a comment, do a binary search for
                            		" the start of the comment.  synID() is slow, a linear search would take
                            		" too long on a long line.
                            		if synIDattr(synID(a:lnum, line_len, 1), "name") =~ 'Comment\|Todo'
                            			let min = 1
                            			let max = line_len
                            			while min < max
                            				let col = (min + max) / 2
                            				if synIDattr(synID(a:lnum, col, 1), "name") =~ 'Comment\|Todo'
                            					let max = col
                            				else
                            					let min = col + 1
                            				endif
                            			endwhile
                            			let line = strpart(line, 0, min - 1)
                            		endif
                            		return substitute(line, "\s*$", "", "")
    3              0.000004 	else
                            		" Sorry, this is not complete, nor fully correct (e.g. string "//").
                            		" Such is life.
    3              0.000084 		return substitute(line, "\s*//.*$", "", "")
                            	endif

FUNCTION  <SNR>77_RequestCancel()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot/agent.vim:204
Called 15 times
Total time:   0.002298
 Self time:   0.000626

count  total (s)   self (s)
   15   0.000388   0.000241   let agent = self.Agent()
   15              0.000051   if !empty(agent)
   15   0.001701   0.000176     call agent.Cancel(self)
                              elseif get(self, 'status', '') ==# 'running'
                                let self.status = 'canceled'
   15              0.000013   endif
   15              0.000027   return self

FUNCTION  copilot#Clear()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:109
Called 23 times
Total time:   0.012737
 Self time:   0.001660

count  total (s)   self (s)
   23              0.000136   if exists('g:_copilot_timer')
    5              0.000034     call timer_stop(remove(g:, '_copilot_timer'))
   23              0.000031   endif
   23              0.000068   if exists('s:uuid')
                                call copilot#Request('notifyRejected', {'uuids': [remove(s:, 'uuid')]})
   23              0.000018   endif
   23              0.000075   if exists('b:_copilot')
   15   0.002882   0.000236     call copilot#agent#Cancel(get(b:_copilot, 'first', {}))
   15   0.000469   0.000274     call copilot#agent#Cancel(get(b:_copilot, 'cycling', {}))
   23              0.000016   endif
   23   0.008532   0.000295   call s:UpdatePreview()
   23              0.000079   unlet! b:_copilot
   23              0.000032   return ''

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:112
Called 51 times
Total time:   0.003822
 Self time:   0.002920

count  total (s)   self (s)
   51   0.003606   0.002704   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
   51              0.000171   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>77_LspNotify()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot/agent.vim:383
Called 13 times
Total time:   0.000904
 Self time:   0.000904

count  total (s)   self (s)
   13              0.000890   return v:lua.require'_copilot'.rpc_notify(self.id, a:method, a:params)

FUNCTION  GetRustIndent()
    Defined: /usr/local/Cellar/neovim/0.8.1/share/nvim/runtime/indent/rust.vim:82
Called 3 times
Total time:   0.001481
 Self time:   0.001179

count  total (s)   self (s)
                            
                            	" Starting assumption: cindent (called at the end) will do it right
                            	" normally. We just want to fix up a few cases.
                            
    3              0.000040 	let line = getline(a:lnum)
                            
    3              0.000026 	if has('syntax_items')
                            		let synname = synIDattr(synID(a:lnum, 1, 1), "name")
                            		if synname == "rustString"
                            			" If the start of the line is in a string, don't change the indent
                            			return -1
                            		elseif synname =~ '\(Comment\|Todo\)' && line !~ '^\s*/\*'  " not /* opening line
                            			if synname =~ "CommentML" " multi-line
                            				if line !~ '^\s*\*' && getline(a:lnum - 1) =~ '^\s*/\*'
                            					" This is (hopefully) the line after a /*, and it has no
                            					" leader, so the correct indentation is that of the
                            					" previous line.
                            					return GetRustIndent(a:lnum - 1)
                            				endif
                            			endif
                            			" If it's in a comment, let cindent take care of it now. This is
                            			" for cases like "/*" where the next line should start " * ", not
                            			" "* " as the code below would otherwise cause for module scope
                            			" Fun fact: "  /*\n*\n*/" takes two calls to get right!
                            			return cindent(a:lnum)
                            		endif
    3              0.000003 	endif
                            
                            	" cindent gets second and subsequent match patterns/struct members wrong,
                            	" as it treats the comma as indicating an unfinished statement::
                            	"
                            	" match a {
                            	"     b => c,
                            	"         d => e,
                            	"         f => g,
                            	" };
                            
                            	" Search backwards for the previous non-empty line.
    3              0.000022 	let prevlinenum = prevnonblank(a:lnum - 1)
    3   0.000392   0.000090 	let prevline = s:get_line_trimmed(prevlinenum)
    3              0.000067 	while prevlinenum > 1 && prevline !~ '[^[:blank:]]'
                            		let prevlinenum = prevnonblank(prevlinenum - 1)
                            		let prevline = s:get_line_trimmed(prevlinenum)
    3              0.000007 	endwhile
                            
                            	" Handle where clauses nicely: subsequent values should line up nicely.
    3              0.000029 	if prevline[len(prevline) - 1] == "," && prevline =~# '^\s*where\s'
                            		return indent(prevlinenum) + 6
    3              0.000009 	endif
                            
    3              0.000059 	if prevline[len(prevline) - 1] == "," && s:get_line_trimmed(a:lnum) !~ '^\s*[\[\]{}]' && prevline !~ '^\s*fn\s' && prevline !~ '([^()]\+,$' && s:get_line_trimmed(a:lnum) !~ '^\s*\S\+\s*=>'
                            		" Oh ho! The previous line ended in a comma! I bet cindent will try to
                            		" take this too far... For now, let's normally use the previous line's
                            		" indent.
                            
                            		" One case where this doesn't work out is where *this* line contains
                            		" square or curly brackets; then we normally *do* want to be indenting
                            		" further.
                            		"
                            		" Another case where we don't want to is one like a function
                            		" definition with arguments spread over multiple lines:
                            		"
                            		" fn foo(baz: Baz,
                            		"        baz: Baz) // <-- cindent gets this right by itself
                            		"
                            		" Another case is similar to the previous, except calling a function
                            		" instead of defining it, or any conditional expression that leaves
                            		" an open paren:
                            		"
                            		" foo(baz,
                            		"     baz);
                            		"
                            		" if baz && (foo ||
                            		"            bar) {
                            		"
                            		" Another case is when the current line is a new match arm.
                            		"
                            		" There are probably other cases where we don't want to do this as
                            		" well. Add them as needed.
                            		return indent(prevlinenum)
    3              0.000003 	endif
                            
    3              0.000018 	if !has("patch-7.4.355")
                            		" cindent before 7.4.355 doesn't do the module scope well at all; e.g.::
                            		"
                            		" static FOO : &'static [bool] = [
                            		" true,
                            		"	 false,
                            		"	 false,
                            		"	 true,
                            		"	 ];
                            		"
                            		"	 uh oh, next statement is indented further!
                            
                            		" Note that this does *not* apply the line continuation pattern properly;
                            		" that's too hard to do correctly for my liking at present, so I'll just
                            		" start with these two main cases (square brackets and not returning to
                            		" column zero)
                            
                            		call cursor(a:lnum, 1)
                            		if searchpair('{\|(', '', '}\|)', 'nbW', 's:is_string_comment(line("."), col("."))') == 0
                            			if searchpair('\[', '', '\]', 'nbW', 's:is_string_comment(line("."), col("."))') == 0
                            				" Global scope, should be zero
                            				return 0
                            			else
                            				" At the module scope, inside square brackets only
                            				"if getline(a:lnum)[0] == ']' || search('\[', '', '\]', 'nW') == a:lnum
                            				if line =~ "^\\s*]"
                            					" It's the closing line, dedent it
                            					return 0
                            				else
                            					return shiftwidth()
                            				endif
                            			endif
                            		endif
    3              0.000002 	endif
                            
                            	" Fall back on cindent, which does it mostly right
    3              0.000406 	return cindent(a:lnum)

FUNCTION  gitgutter#utility#windows()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:253
Called 51 times
Total time:   0.000538
 Self time:   0.000538

count  total (s)   self (s)
   51              0.000499   return has('win64') || has('win32') || has('win16')

FUNCTION  copilot#NvimNs()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:105
Called 25 times
Total time:   0.000241
 Self time:   0.000241

count  total (s)   self (s)
   25              0.000221   return nvim_create_namespace('github-copilot')

FUNCTION  <SNR>29_unc_path()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:186
Called 51 times
Total time:   0.006571
 Self time:   0.000727

count  total (s)   self (s)
   51   0.006541   0.000697   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  copilot#IsMapped()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:433
Called 3 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    3              0.000053   return get(g:, 'copilot_assume_mapped') || hasmapto('copilot#Accept(', 'i')

FUNCTION  copilot#Schedule()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:439
Called 20 times
Total time:   0.014492
 Self time:   0.000812

count  total (s)   self (s)
   20   0.010647   0.000153   call copilot#Clear()
   20   0.003370   0.000185   if !s:is_mapped || !s:dest || !copilot#Enabled()
                                return
   20              0.000014   endif
   20              0.000118   let delay = a:0 ? a:1 : get(g:, 'copilot_idle_delay', 75)
   20              0.000273   let g:_copilot_timer = timer_start(delay, function('s:Trigger', [bufnr('')]))

FUNCTION  copilot#Enabled()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:162
Called 20 times
Total time:   0.003185
 Self time:   0.000850

count  total (s)   self (s)
   20   0.003171   0.000836   return get(g:, 'copilot_enabled', 1) && empty(s:BufferDisabled()) && empty(copilot#Agent().StartupError())

FUNCTION  gitgutter#async#execute()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:16
Called 51 times
Total time:   0.049691
 Self time:   0.046791

count  total (s)   self (s)
   51   0.003494   0.000918   call gitgutter#debug#log('[async] '.a:cmd)
                            
   51              0.000405   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
   51   0.000853   0.000530   let command = s:build_command(a:cmd)
                            
   51              0.000174   if has('nvim')
   51              0.043546     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
                                let job = job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
                                let s:jobs[s:job_id(job)] = 1
   51              0.000044   endif

FUNCTION  gitgutter#setup_maps()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter.vim:120
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000002   if !g:gitgutter_map_keys
    1              0.000002     return
                              endif
                            
                              " Note hasmapto() and maparg() operate on the current buffer.
                            
                              let bufnr = bufnr('')
                            
                              if gitgutter#utility#getbufvar(bufnr, 'mapped', 0)
                                return
                              endif
                            
                              if !hasmapto('<Plug>(GitGutterPrevHunk)') && maparg('[c', 'n') ==# ''
                                nmap <buffer> [c <Plug>(GitGutterPrevHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterNextHunk)') && maparg(']c', 'n') ==# ''
                                nmap <buffer> ]c <Plug>(GitGutterNextHunk)
                              endif
                            
                              if !hasmapto('<Plug>(GitGutterStageHunk)', 'v') && maparg('<Leader>hs', 'x') ==# ''
                                xmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterStageHunk)', 'n') && maparg('<Leader>hs', 'n') ==# ''
                                nmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterUndoHunk)') && maparg('<Leader>hu', 'n') ==# ''
                                nmap <buffer> <Leader>hu <Plug>(GitGutterUndoHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterPreviewHunk)') && maparg('<Leader>hp', 'n') ==# ''
                                nmap <buffer> <Leader>hp <Plug>(GitGutterPreviewHunk)
                              endif
                            
                              if !hasmapto('<Plug>(GitGutterTextObjectInnerPending)') && maparg('ic', 'o') ==# ''
                                omap <buffer> ic <Plug>(GitGutterTextObjectInnerPending)
                              endif
                              if !hasmapto('<Plug>(GitGutterTextObjectOuterPending)') && maparg('ac', 'o') ==# ''
                                omap <buffer> ac <Plug>(GitGutterTextObjectOuterPending)
                              endif
                              if !hasmapto('<Plug>(GitGutterTextObjectInnerVisual)') && maparg('ic', 'x') ==# ''
                                xmap <buffer> ic <Plug>(GitGutterTextObjectInnerVisual)
                              endif
                              if !hasmapto('<Plug>(GitGutterTextObjectOuterVisual)') && maparg('ac', 'x') ==# ''
                                xmap <buffer> ac <Plug>(GitGutterTextObjectOuterVisual)
                              endif
                            
                              call gitgutter#utility#setbufvar(bufnr, 'mapped', 1)

FUNCTION  copilot#agent#Result()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot/agent.vim:555
Called 15 times
Total time:   0.000240
 Self time:   0.000240

count  total (s)   self (s)
   15              0.000047   if has_key(a:request, 'resolve')
   15              0.000052     call add(a:request.resolve, a:callback)
                              elseif has_key(a:request, 'result')
                                let a:request.waiting[timer_start(0, function('s:Callback', [a:request, 'result', a:callback]))] = 1
   15              0.000009   endif

FUNCTION  <SNR>29_abs_path()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:222
Called 255 times
Total time:   0.032989
 Self time:   0.032989

count  total (s)   self (s)
  255              0.025032   let p = resolve(expand('#'.a:bufnr.':p'))
                            
                              " Remove extra parts from fugitive's filepaths
  255              0.006134   let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                            
  255              0.001076   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:50
Called 52 times
Total time:   0.036031
 Self time:   0.002728

count  total (s)   self (s)
   52   0.035960   0.002657   return gitgutter#utility#getbufvar(a:bufnr, 'enabled') && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  provider#clipboard#Call()
    Defined: /usr/local/Cellar/neovim/0.8.1/share/nvim/runtime/autoload/provider/clipboard.vim:230
Called 3 times
Total time:   0.068368
 Self time:   0.000165

count  total (s)   self (s)
    3              0.000048   if get(s:, 'here', v:false)  " Clipboard provider must not recurse. #7184
                                return 0
    3              0.000005   endif
    3              0.000017   let s:here = v:true
    3              0.000005   try
    3   0.068256   0.000054     return call(s:clipboard[a:method],a:args,s:clipboard)
    3              0.000004   finally
    3              0.000006     let s:here = v:false
    3              0.000003   endtry

FUNCTION  copilot#doc#UTF16Width()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot/doc.vim:10
Called 15 times
Total time:   0.000213
 Self time:   0.000213

count  total (s)   self (s)
   15              0.000200   return strchars(substitute(a:str, "\\%#=2[^\u0001-\uffff]", "  ", 'g'))

FUNCTION  copilot#agent#LspResponse()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot/agent.vim:358
Called 15 times
Total time:   0.001133
 Self time:   0.000322

count  total (s)   self (s)
   15              0.000094   if !has_key(s:instances, a:agent_id)
                                return
   15              0.000011   endif
   15   0.000985   0.000174   call s:OnResponse(s:instances[a:agent_id], a:opts)

FUNCTION  <SNR>77_AgentCancel()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot/agent.vim:194
Called 15 times
Total time:   0.001525
 Self time:   0.000621

count  total (s)   self (s)
   15              0.000111   if has_key(self.requests, get(a:request, 'id', ''))
   13              0.000073     call remove(self.requests, a:request.id)
   13   0.001094   0.000190     call self.Notify('$/cancelRequest', {'id': a:request.id})
   15              0.000027   endif
   15              0.000093   if get(a:request, 'status', '') ==# 'running'
   13              0.000049     let a:request.status = 'canceled'
   15              0.000012   endif

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:21
Called 155 times
Total time:   0.003219
 Self time:   0.003219

count  total (s)   self (s)
  155              0.001146   let ggvars = getbufvar(a:buffer, 'gitgutter')
  155              0.001335   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
  154              0.000456     return ggvars[a:varname]
    1              0.000001   endif
    1              0.000001   if a:0
    1              0.000001     return a:1
                              endif

FUNCTION  <SNR>86_on_exit_nvim()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:72
Called 51 times
Total time:   0.000525
 Self time:   0.000525

count  total (s)   self (s)
   51              0.000171   if !a:exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
   51              0.000042   endif

FUNCTION  <SNR>41_SuggestionTextWithAdjustments()
    Defined: ~/.local/share/nvim/plugged/copilot.vim/autoload/copilot.vim:193
Called 25 times
Total time:   0.003261
 Self time:   0.003064

count  total (s)   self (s)
   25              0.000028   try
   25   0.000998   0.000801     if mode() !~# '^[iR]' || (s:HideDuringCompletion() && pumvisible()) || !s:dest || !exists('b:_copilot.suggestions')
   22              0.000088       return ['', 0, 0, '']
    3              0.000002     endif
    3              0.000013     let choice = get(b:_copilot.suggestions, b:_copilot.choice, {})
    3              0.000013     if !has_key(choice, 'range') || choice.range.start.line != line('.') - 1
    3              0.000007       return ['', 0, 0, '']
                                endif
                                let line = getline('.')
                                let offset = col('.') - 1
                                if choice.range.start.character != 0
                                  call copilot#logger#Warn('unexpected range ' . json_encode(choice.range))
                                  return ['', 0, 0, '']
                                endif
                                let typed = strpart(line, 0, offset)
                                let delete = strpart(line, offset)
                                if choice.range.end.line == line('.') - 1 && choice.range.end.character < copilot#doc#UTF16Width(line)
                                  let append = delete
                                else
                                  let append = ''
                                endif
                                let uuid = get(choice, 'uuid', '')
                                if typed =~# '^\s*$'
                                  let leading = matchstr(choice.text, '^\s\+')
                                  let unindented = strpart(choice.text, len(leading))
                                  if strpart(typed, 0, len(leading)) == leading && unindented !=# delete
                                    return [unindented, len(typed) - len(leading), strchars(delete), uuid]
                                  endif
                                elseif typed ==# strpart(choice.text, 0, offset)
                                  return [strpart(choice.text . append, offset), 0, strchars(delete), uuid]
                                endif
                              catch
                                call copilot#logger#Exception()
   25              0.000040   endtry
                              return ['', 0, 0, '']

FUNCTION  <SNR>73_try_cmd()
    Defined: /usr/local/Cellar/neovim/0.8.1/share/nvim/runtime/autoload/provider/clipboard.vim:37
Called 3 times
Total time:   0.067875
 Self time:   0.000402

count  total (s)   self (s)
    3   0.067785   0.000313   let out = systemlist(a:cmd, (a:0 ? a:1 : ['']), 1)
    3              0.000021   if v:shell_error
                                if !exists('s:did_error_try_cmd')
                                  echohl WarningMsg
                                  echomsg "clipboard: error: ".(len(out) ? out[0] : v:shell_error)
                                  echohl None
                                  let s:did_error_try_cmd = 1
                                endif
                                return 0
    3              0.000002   endif
    3              0.000005   return out

FUNCTION  <SNR>29_exists_file()
    Defined: ~/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:240
Called 51 times
Total time:   0.011441
 Self time:   0.001951

count  total (s)   self (s)
   51   0.011403   0.001912   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   52   0.140425   0.010048  gitgutter#process_buffer()
   51   0.092825   0.001430  <SNR>68_setup_path()
   51   0.086737   0.006011  gitgutter#utility#set_repo_path()
    3   0.068368   0.000165  provider#clipboard#Call()
    3   0.067875   0.000402  <SNR>73_try_cmd()
   51   0.049691   0.046791  gitgutter#async#execute()
    2   0.040289   0.000189  16()
   52   0.036031   0.002728  gitgutter#utility#is_active()
  255   0.032989             <SNR>29_abs_path()
  102   0.028158   0.002174  <SNR>29_dir()
    1   0.027914   0.000139  15()
  503   0.026059             lightline#link()
  110   0.023295   0.020310  <SNR>46_Highlight_Matching_Pair()
   51   0.021443   0.005697  gitgutter#utility#cd_cmd()
   51   0.020593   0.001072  <SNR>29_not_git_dir()
   23   0.018982   0.000685  <SNR>40_Event()
   15   0.017890   0.000596  <SNR>41_Trigger()
   15   0.017294   0.000430  copilot#Suggest()
   15   0.016864   0.001315  copilot#Complete()
   38   0.016833   0.001286  copilot#agent#LspHandle()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   51   0.049691   0.046791  gitgutter#async#execute()
  255              0.032989  <SNR>29_abs_path()
  503              0.026059  lightline#link()
  110   0.023295   0.020310  <SNR>46_Highlight_Matching_Pair()
  153              0.015911  gitgutter#utility#shellescape()
   13   0.013255   0.013209  copilot#logger#Raw()
   52   0.140425   0.010048  gitgutter#process_buffer()
   15   0.008706   0.007174  copilot#doc#Get()
   51   0.086737   0.006011  gitgutter#utility#set_repo_path()
   51   0.021443   0.005697  gitgutter#utility#cd_cmd()
   25   0.008597   0.004448  <SNR>41_UpdatePreview()
   15   0.005010   0.003792  <SNR>77_LspRequest()
  155              0.003219  gitgutter#utility#getbufvar()
   53   0.016358   0.003103  <SNR>77_OnResponse()
   25   0.003261   0.003064  <SNR>41_SuggestionTextWithAdjustments()
  110              0.002985  <SNR>46_Remove_Matches()
   51   0.003822   0.002920  gitgutter#utility#repo_path()
   52   0.036031   0.002728  gitgutter#utility#is_active()
  503              0.002703  lightline#mode()
   51              0.002576  gitgutter#debug#log()

